//! Embedded 8x8 bitmap font for software text rendering.
//!
//! Covers printable ASCII (0x20 - 0x7E, 95 glyphs). Each glyph is 8 rows of
//! 8 bits, MSB = leftmost pixel. Based on the classic IBM CGA/BIOS 8x8 font
//! which is in the public domain.
//!
//! This module is the single source of truth for the bitmap font data used by
//! all backends (SDL, UE5, PSP). Backend `font.rs` files re-export from here.

/// Width of each glyph in pixels.
pub const GLYPH_WIDTH: u32 = 8;

/// Height of each glyph in pixels.
pub const GLYPH_HEIGHT: u32 = 8;

/// First printable ASCII code in the table.
const FIRST_CHAR: u8 = 0x20;

/// Last printable ASCII code in the table.
const LAST_CHAR: u8 = 0x7E;

/// 95 glyphs, 8 bytes each (ASCII 32-126).
#[rustfmt::skip]
static FONT_DATA: [[u8; 8]; 95] = [
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], //   (32)
    [0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00], // ! (33)
    [0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00], // " (34)
    [0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00], // # (35)
    [0x18, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x18, 0x00], // $ (36)
    [0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00], // % (37)
    [0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00], // & (38)
    [0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00], // ' (39)
    [0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00], // ( (40)
    [0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00], // ) (41)
    [0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00], // * (42)
    [0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00], // + (43)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30], // , (44)
    [0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00], // - (45)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00], // . (46)
    [0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00], // / (47)
    [0x3C, 0x66, 0x6E, 0x7E, 0x76, 0x66, 0x3C, 0x00], // 0 (48)
    [0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00], // 1 (49)
    [0x3C, 0x66, 0x06, 0x0C, 0x18, 0x30, 0x7E, 0x00], // 2 (50)
    [0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00], // 3 (51)
    [0x0C, 0x1C, 0x3C, 0x6C, 0x7E, 0x0C, 0x0C, 0x00], // 4 (52)
    [0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00], // 5 (53)
    [0x1C, 0x30, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00], // 6 (54)
    [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00], // 7 (55)
    [0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00], // 8 (56)
    [0x3C, 0x66, 0x66, 0x3E, 0x06, 0x0C, 0x38, 0x00], // 9 (57)
    [0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00], // : (58)
    [0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30], // ; (59)
    [0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00], // < (60)
    [0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00], // = (61)
    [0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x00], // > (62)
    [0x3C, 0x66, 0x06, 0x0C, 0x18, 0x00, 0x18, 0x00], // ? (63)
    [0x3C, 0x66, 0x6E, 0x6A, 0x6E, 0x60, 0x3C, 0x00], // @ (64)
    [0x18, 0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x00], // A (65)
    [0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00], // B (66)
    [0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00], // C (67)
    [0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00], // D (68)
    [0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x7E, 0x00], // E (69)
    [0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x00], // F (70)
    [0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3E, 0x00], // G (71)
    [0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00], // H (72)
    [0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00], // I (73)
    [0x06, 0x06, 0x06, 0x06, 0x06, 0x66, 0x3C, 0x00], // J (74)
    [0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00], // K (75)
    [0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00], // L (76)
    [0xC6, 0xEE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0x00], // M (77)
    [0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00], // N (78)
    [0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00], // O (79)
    [0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00], // P (80)
    [0x3C, 0x66, 0x66, 0x66, 0x6A, 0x6C, 0x36, 0x00], // Q (81)
    [0x7C, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0x00], // R (82)
    [0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00], // S (83)
    [0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00], // T (84)
    [0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00], // U (85)
    [0x66, 0x66, 0x66, 0x66, 0x3C, 0x3C, 0x18, 0x00], // V (86)
    [0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00], // W (87)
    [0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00], // X (88)
    [0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00], // Y (89)
    [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00], // Z (90)
    [0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00], // [ (91)
    [0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00], // \ (92)
    [0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00], // ] (93)
    [0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00], // ^ (94)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE], // _ (95)
    [0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00], // ` (96)
    [0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E, 0x00], // a (97)
    [0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x00], // b (98)
    [0x00, 0x00, 0x3C, 0x66, 0x60, 0x66, 0x3C, 0x00], // c (99)
    [0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00], // d (100)
    [0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00], // e (101)
    [0x0E, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x18, 0x00], // f (102)
    [0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x3C], // g (103)
    [0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00], // h (104)
    [0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00], // i (105)
    [0x06, 0x00, 0x06, 0x06, 0x06, 0x06, 0x66, 0x3C], // j (106)
    [0x60, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0x00], // k (107)
    [0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00], // l (108)
    [0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xC6, 0xC6, 0x00], // m (109)
    [0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00], // n (110)
    [0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00], // o (111)
    [0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60], // p (112)
    [0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x06], // q (113)
    [0x00, 0x00, 0x7C, 0x66, 0x60, 0x60, 0x60, 0x00], // r (114)
    [0x00, 0x00, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x00], // s (115)
    [0x18, 0x18, 0x7E, 0x18, 0x18, 0x18, 0x0E, 0x00], // t (116)
    [0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00], // u (117)
    [0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00], // v (118)
    [0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xFE, 0x6C, 0x00], // w (119)
    [0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x00], // x (120)
    [0x00, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x3C], // y (121)
    [0x00, 0x00, 0x7E, 0x0C, 0x18, 0x30, 0x7E, 0x00], // z (122)
    [0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00], // { (123)
    [0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00], // | (124)
    [0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00], // } (125)
    [0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // ~ (126)
];

/// Look up glyph data for a character. Returns 8 bytes (one per row).
/// Non-printable or out-of-range characters get a filled-block fallback.
pub fn glyph(ch: char) -> &'static [u8; 8] {
    let code = ch as u32;
    if code >= FIRST_CHAR as u32 && code <= LAST_CHAR as u32 {
        &FONT_DATA[(code - FIRST_CHAR as u32) as usize]
    } else {
        // Fallback: filled block.
        static FALLBACK: [u8; 8] = [0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0x00];
        &FALLBACK
    }
}

// ---------------------------------------------------------------------------
// Proportional glyph metrics
// ---------------------------------------------------------------------------

/// Compute `(left_pad, advance)` for a single glyph from its bitmap data.
///
/// - `left_pad`: leftmost column containing ink (0-7).
/// - `advance`: horizontal distance to the next glyph (`ink_width + 1`, clamped to \[3, 8\]).
///
/// Space (all-zero bitmap) returns `(0, 4)`.
const fn compute_metrics(data: &[u8; 8]) -> (u8, u8) {
    let mut leftmost: u8 = 8;
    let mut rightmost: u8 = 0;
    let mut has_ink = false;

    let mut row = 0;
    while row < 8 {
        let bits = data[row];
        if bits != 0 {
            let mut col: u8 = 0;
            while col < 8 {
                if bits & (0x80 >> col) != 0 {
                    if col < leftmost {
                        leftmost = col;
                    }
                    if col > rightmost || !has_ink {
                        rightmost = col;
                    }
                    has_ink = true;
                }
                col += 1;
            }
        }
        row += 1;
    }

    if !has_ink {
        // Space or blank glyph.
        return (0, 4);
    }

    let ink_width = rightmost - leftmost + 1;
    let mut advance = ink_width + 1;
    if advance < 3 {
        advance = 3;
    }
    if advance > 8 {
        advance = 8;
    }
    (leftmost, advance)
}

/// Compute metrics for all 95 printable ASCII glyphs at compile time.
const fn compute_all_metrics() -> [(u8, u8); 95] {
    let mut table = [(0u8, 8u8); 95];
    let mut i = 0;
    while i < 95 {
        table[i] = compute_metrics(&FONT_DATA[i]);
        i += 1;
    }
    table
}

/// Pre-computed `(left_pad, advance)` for ASCII 0x20..=0x7E.
static GLYPH_METRICS: [(u8, u8); 95] = compute_all_metrics();

/// Return `(left_pad, advance)` for a character.
///
/// - `left_pad`: first column with ink (used to shift rendering).
/// - `advance`: horizontal pixels consumed (including 1px inter-glyph gap).
///
/// Non-printable / out-of-range characters return `(0, 8)` (full-width).
pub fn glyph_metrics(ch: char) -> (u8, u8) {
    let code = ch as u32;
    if code >= FIRST_CHAR as u32 && code <= LAST_CHAR as u32 {
        GLYPH_METRICS[(code - FIRST_CHAR as u32) as usize]
    } else {
        (0, 8)
    }
}

/// Return the proportional advance width for a character (in pixels at scale 1).
pub fn glyph_advance(ch: char) -> u32 {
    glyph_metrics(ch).1 as u32
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn space_is_blank() {
        let g = glyph(' ');
        assert!(g.iter().all(|&b| b == 0));
    }

    #[test]
    fn capital_a_has_pixels() {
        let g = glyph('A');
        let total_bits: u32 = g.iter().map(|b| b.count_ones()).sum();
        assert!(total_bits > 10);
    }

    #[test]
    fn fallback_for_nonprintable() {
        let g = glyph('\x01');
        assert_eq!(g[0], 0xFE);
    }

    #[test]
    fn tilde_is_last() {
        let g = glyph('~');
        assert!(g.iter().any(|&b| b != 0));
    }

    #[test]
    fn all_printable_covered() {
        for code in 0x20u8..=0x7E {
            let ch = code as char;
            let g = glyph(ch);
            assert_eq!(g.len(), 8);
        }
    }

    // -- Proportional metrics tests --

    #[test]
    fn space_advance_is_4() {
        assert_eq!(glyph_advance(' '), 4);
    }

    #[test]
    fn narrow_chars_less_than_8() {
        assert!(glyph_advance('i') < 8);
        assert!(glyph_advance('!') < 8);
        assert!(glyph_advance('.') < 8);
        assert!(glyph_advance('l') < 8);
    }

    #[test]
    fn wide_chars_are_8() {
        assert_eq!(glyph_advance('M'), 8);
        assert_eq!(glyph_advance('W'), 8);
    }

    #[test]
    fn advance_clamped_min_3() {
        for code in 0x20u8..=0x7E {
            let adv = glyph_advance(code as char);
            assert!(adv >= 3, "char {:?} advance {} < 3", code as char, adv);
        }
    }

    #[test]
    fn advance_clamped_max_8() {
        for code in 0x20u8..=0x7E {
            let adv = glyph_advance(code as char);
            assert!(adv <= 8, "char {:?} advance {} > 8", code as char, adv);
        }
    }

    #[test]
    fn fallback_advance_is_8() {
        assert_eq!(glyph_advance('\x01'), 8);
        assert_eq!(glyph_advance('\u{0100}'), 8);
    }

    #[test]
    fn metrics_left_pad_within_bounds() {
        for code in 0x20u8..=0x7E {
            let (left_pad, _) = glyph_metrics(code as char);
            assert!(
                left_pad <= 7,
                "char {:?} left_pad {} > 7",
                code as char,
                left_pad
            );
        }
    }

    #[test]
    fn specific_advances() {
        // '!' has thin vertical stroke: cols 3-4, ink_width=2, advance=3
        assert_eq!(glyph_advance('!'), 3);
        // '.' has two rows of 0x18: cols 3-4, ink_width=2, advance=3
        assert_eq!(glyph_advance('.'), 3);
        // 'i' extends cols 2-5, ink_width=4, advance=5
        assert_eq!(glyph_advance('i'), 5);
        // 'A' extends cols 1-6, ink_width=6, advance=7
        assert_eq!(glyph_advance('A'), 7);
    }
}
