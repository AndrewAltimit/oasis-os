//! Display framebuffer hook via CFW syscall patching.
//!
//! Intercepts `sceDisplaySetFrameBuf` to draw the overlay on top of the
//! game's framebuffer after each frame. The hook calls the original function
//! first (so the game renders normally), then draws overlay elements.
//!
//! # Kernel stub workaround
//!
//! The PSP firmware patches kernel import stubs with `j target` (direct
//! jump) but does NOT write a `nop` to the delay slot. We extract the
//! jump target and call the function directly via raw pointer.
//!
//! # Inline hook fallback
//!
//! If `sctrlHENPatchSyscall` fails (e.g. another plugin already hooked
//! the syscall table entry), we fall back to inline hooking: overwrite the
//! first two instructions of the target function with `j our_hook; nop`
//! and build a trampoline with the saved instructions for calling the
//! original.

use crate::overlay;

use core::sync::atomic::{AtomicBool, Ordering};

/// Whether the hook is currently installed.
static HOOK_INSTALLED: AtomicBool = AtomicBool::new(false);

/// Original `sceDisplaySetFrameBuf` function pointer.
static mut ORIGINAL_SET_FRAME_BUF: Option<
    unsafe extern "C" fn(*const u8, usize, u32, u32) -> u32,
> = None;

/// NID for sceDisplaySetFrameBuf.
const NID_SCE_DISPLAY_SET_FRAME_BUF: u32 = 0x289D82FE;

/// Trampoline for calling the original function after inline hooking.
/// Layout: [saved_instr1, saved_instr2, j_original_plus_8, nop]
/// Must be 16-byte aligned for cache coherency.
#[repr(C, align(16))]
struct Trampoline([u32; 4]);

static mut TRAMPOLINE: Trampoline = Trampoline([0; 4]);

// Reference the raw stub symbols generated by psp_extern! for
// SystemCtrlForKernel functions.
unsafe extern "C" {
    #[link_name = "__sctrlHENFindFunction_stub"]
    static FIND_FUNC_STUB: [u32; 2];

    #[link_name = "__sctrlHENPatchSyscall_stub"]
    static PATCH_SYSCALL_STUB: [u32; 2];
}

/// Encode a MIPS `j target` instruction.
///
/// The `j` instruction uses the upper 4 bits of the current PC combined
/// with a 26-bit word index: `PC[31:28] | (target[27:2])`.
fn encode_j(target: u32) -> u32 {
    0x0800_0000 | ((target >> 2) & 0x03FF_FFFF)
}

/// Extract the absolute target address from a MIPS `j` instruction.
fn extract_j_target(instruction: u32, pc: u32) -> Option<u32> {
    if (instruction >> 26) != 2 {
        return None;
    }
    let offset = (instruction & 0x03FF_FFFF) << 2;
    let region = pc & 0xF000_0000;
    Some(region | offset)
}

/// Check if a stub word looks like a resolved import.
fn is_stub_resolved(first_word: u32) -> bool {
    first_word == 0x03E00008 || (first_word >> 26) == 2
}

/// Resolve a kernel import stub to a direct function pointer.
unsafe fn resolve_kernel_stub(stub: &[u32; 2]) -> Option<u32> {
    let first_word = unsafe {
        core::ptr::read_volatile(&raw const *stub as *const u32)
    };
    if !is_stub_resolved(first_word) {
        return None;
    }
    let stub_addr = &raw const *stub as u32;
    extract_j_target(first_word, stub_addr)
}

/// Our hook function that replaces `sceDisplaySetFrameBuf`.
///
/// # Safety
/// Called by the PSP OS as a syscall replacement.
unsafe extern "C" fn hooked_set_frame_buf(
    top_addr: *const u8,
    buffer_width: usize,
    pixel_format: u32,
    sync: u32,
) -> u32 {
    // Call original first so the game's frame is displayed
    // SAFETY: ORIGINAL_SET_FRAME_BUF is set before the hook is active.
    let result = unsafe {
        if let Some(original) = ORIGINAL_SET_FRAME_BUF {
            original(top_addr, buffer_width, pixel_format, sync)
        } else {
            0
        }
    };

    // Only draw overlay on 32-bit ABGR framebuffers (pixel_format == 3)
    if !top_addr.is_null() && pixel_format == 3 {
        let fb = top_addr as *mut u32;
        let stride = buffer_width as u32;

        // Debug beacon: 2x2 green dot at (1,1) confirms the hook is running.
        // SAFETY: Writing within screen bounds to valid framebuffer.
        unsafe {
            *fb.add((1 * stride + 1) as usize) = 0xFF00FF00;
            *fb.add((1 * stride + 2) as usize) = 0xFF00FF00;
            *fb.add((2 * stride + 1) as usize) = 0xFF00FF00;
            *fb.add((2 * stride + 2) as usize) = 0xFF00FF00;
        }

        // SAFETY: fb is a valid framebuffer pointer provided by the OS.
        unsafe {
            overlay::on_frame(fb, stride);
        }
    }

    result
}

/// Module/library name pairs to try for finding sceDisplaySetFrameBuf.
const DISPLAY_MODULE_NAMES: &[(&[u8], &[u8])] = &[
    (b"sceDisplay_Service\0", b"sceDisplay\0"),
    (b"sceDisplay\0", b"sceDisplay\0"),
    (b"sceDisplay_Service\0", b"sceDisplay_driver\0"),
    (b"sceDisplay\0", b"sceDisplay_driver\0"),
];

/// Install a hook on `sceDisplaySetFrameBuf` using inline patching.
///
/// Overwrites the first two instructions of the target function with a
/// `j our_hook; nop` sequence, and builds a trampoline to call the
/// original function.
///
/// # Safety
/// `func_addr` must be a valid kernel function address.
unsafe fn install_inline_hook(func_addr: *mut u8) -> bool {
    let func_ptr = func_addr as *mut u32;

    // SAFETY: Reading the first two instructions of the kernel function.
    let instr1 = unsafe { core::ptr::read_volatile(func_ptr) };
    let instr2 = unsafe { core::ptr::read_volatile(func_ptr.add(1)) };

    // Log original instructions for diagnostics.
    {
        let mut buf = [0u8; 48];
        let mut pos = write_log_bytes(&mut buf, 0, b"[OASIS] orig: ");
        pos = write_log_hex(&mut buf, pos, instr1);
        pos = write_log_bytes(&mut buf, pos, b" ");
        pos = write_log_hex(&mut buf, pos, instr2);
        crate::debug_log(&buf[..pos]);
    }

    // Check if instr1 or instr2 are branch/jump instructions
    // (PC-relative). These can't be safely relocated to the trampoline.
    // Opcodes: beq=4, bne=5, blez=6, bgtz=7, j=2, jal=3
    // Also: regimm=1 (bltz, bgez, etc.)
    let op1 = instr1 >> 26;
    let op2 = instr2 >> 26;
    let is_branch = |op: u32| matches!(op, 1 | 2 | 3 | 4 | 5 | 6 | 7);

    if is_branch(op1) || is_branch(op2) {
        crate::debug_log(b"[OASIS] inline: branch in first 8 bytes, abort");
        return false;
    }

    // SAFETY: Building the trampoline with saved instructions.
    unsafe {
        let orig_plus_8 = func_addr as u32 + 8;
        TRAMPOLINE.0[0] = instr1;
        TRAMPOLINE.0[1] = instr2;
        TRAMPOLINE.0[2] = encode_j(orig_plus_8);
        TRAMPOLINE.0[3] = 0x0000_0000; // nop (delay slot)

        // Patch the original function entry point.
        let hook_addr = hooked_set_frame_buf as *const () as u32;
        core::ptr::write_volatile(func_ptr, encode_j(hook_addr));
        core::ptr::write_volatile(func_ptr.add(1), 0x0000_0000); // nop

        // Flush data cache and invalidate instruction cache.
        psp::sys::sceKernelDcacheWritebackAll();
        psp::sys::sceKernelIcacheInvalidateAll();

        // Set original to point to trampoline.
        ORIGINAL_SET_FRAME_BUF = Some(core::mem::transmute(
            &raw const TRAMPOLINE.0[0],
        ));
    }

    crate::debug_log(b"[OASIS] inline hook installed OK");
    true
}

/// Install the `sceDisplaySetFrameBuf` hook.
///
/// Returns `true` on success. Must be called from kernel mode during plugin
/// initialization.
pub fn install_display_hook() -> bool {
    if HOOK_INSTALLED.load(Ordering::Relaxed) {
        return true;
    }

    // Log raw stub bytes for diagnostics.
    {
        let (w0, w1) = unsafe {
            let p = &raw const FIND_FUNC_STUB as *const u32;
            (
                core::ptr::read_volatile(p),
                core::ptr::read_volatile(p.add(1)),
            )
        };
        let mut buf = [0u8; 64];
        let mut pos = write_log_bytes(&mut buf, 0, b"[OASIS] stub: ");
        pos = write_log_hex(&mut buf, pos, w0);
        pos = write_log_bytes(&mut buf, pos, b" ");
        pos = write_log_hex(&mut buf, pos, w1);
        crate::debug_log(&buf[..pos]);
    }

    // Resolve CFW function pointers from patched kernel stubs.
    // SAFETY: Reading stub data written by firmware at load time.
    let find_func_addr = unsafe { resolve_kernel_stub(&FIND_FUNC_STUB) };
    let patch_syscall_addr = unsafe { resolve_kernel_stub(&PATCH_SYSCALL_STUB) };

    let find_addr = match find_func_addr {
        Some(f) => {
            let mut buf = [0u8; 48];
            let mut pos = write_log_bytes(&mut buf, 0, b"[OASIS] FindFunc=0x");
            pos = write_log_hex(&mut buf, pos, f);
            crate::debug_log(&buf[..pos]);
            f
        }
        None => {
            crate::debug_log(b"[OASIS] hook: FindFunc stub NOT resolved!");
            return false;
        }
    };

    // Cast FindFunction to the correct type.
    let sctrl_find_function: unsafe extern "C" fn(
        *const u8, *const u8, u32,
    ) -> *mut u8 = unsafe { core::mem::transmute(find_addr) };

    // Wait for CFW and game to fully initialize.
    crate::debug_log(b"[OASIS] hook: waiting for system init...");
    unsafe {
        psp::sys::sceKernelDelayThread(2_000_000);
    }
    crate::debug_log(b"[OASIS] hook: calling FindFunc...");

    unsafe {
        psp::sys::sceKernelDcacheWritebackAll();

        // Find sceDisplaySetFrameBuf.
        let mut display_ptr: *mut u8 = core::ptr::null_mut();
        for &(module, library) in DISPLAY_MODULE_NAMES {
            let ptr = sctrl_find_function(
                module.as_ptr(),
                library.as_ptr(),
                NID_SCE_DISPLAY_SET_FRAME_BUF,
            );
            if !ptr.is_null() {
                display_ptr = ptr;
                let mut buf = [0u8; 80];
                let mut pos = write_log_bytes(&mut buf, 0, b"[OASIS] found at mod=");
                pos = write_log_cstr(&mut buf, pos, module);
                pos = write_log_bytes(&mut buf, pos, b" -> 0x");
                pos = write_log_hex(&mut buf, pos, ptr as u32);
                crate::debug_log(&buf[..pos]);
                break;
            }
        }

        if display_ptr.is_null() {
            crate::debug_log(b"[OASIS] hook: FindFunc returned NULL for all");
            return false;
        }

        // Try sctrlHENPatchSyscall first (preferred method).
        let mut hooked = false;
        if let Some(patch_addr) = patch_syscall_addr {
            let sctrl_patch_syscall: unsafe extern "C" fn(
                *mut u8, *mut u8,
            ) -> i32 = core::mem::transmute(patch_addr);

            crate::debug_log(b"[OASIS] hook: trying PatchSyscall...");
            let ret = sctrl_patch_syscall(
                display_ptr,
                hooked_set_frame_buf as *mut u8,
            );

            if ret >= 0 {
                ORIGINAL_SET_FRAME_BUF =
                    Some(core::mem::transmute(display_ptr));
                hooked = true;
                crate::debug_log(b"[OASIS] hook: PatchSyscall OK");
            } else {
                let mut buf = [0u8; 48];
                let mut pos = write_log_bytes(&mut buf, 0, b"[OASIS] PatchSyscall ret=");
                pos = write_log_hex(&mut buf, pos, ret as u32);
                crate::debug_log(&buf[..pos]);
            }
        }

        // Fallback: inline hook (patch the function bytes directly).
        if !hooked {
            crate::debug_log(b"[OASIS] hook: falling back to inline hook");
            if !install_inline_hook(display_ptr) {
                crate::debug_log(b"[OASIS] hook: inline hook FAILED");
                return false;
            }
        }

        psp::sys::sceKernelIcacheInvalidateAll();
        psp::sys::sceKernelDcacheWritebackAll();

        HOOK_INSTALLED.store(true, Ordering::Release);
    }

    true
}

/// Log diagnostic info about sctrlHENFindFunction results.
pub fn log_find_function_result() {
    let Some(addr) = (unsafe { resolve_kernel_stub(&FIND_FUNC_STUB) }) else {
        crate::debug_log(b"[OASIS] log: skipping (stubs not resolved)");
        return;
    };

    let sctrl_find_function: unsafe extern "C" fn(
        *const u8, *const u8, u32,
    ) -> *mut u8 = unsafe { core::mem::transmute(addr) };

    unsafe {
        for &(module, library) in DISPLAY_MODULE_NAMES {
            let ptr = sctrl_find_function(
                module.as_ptr(),
                library.as_ptr(),
                NID_SCE_DISPLAY_SET_FRAME_BUF,
            );

            let mut buf = [0u8; 96];
            let mut pos = 0usize;
            pos = write_log_bytes(&mut buf, pos, b"[OASIS] FindFunc mod=");
            pos = write_log_cstr(&mut buf, pos, module);
            pos = write_log_bytes(&mut buf, pos, b" lib=");
            pos = write_log_cstr(&mut buf, pos, library);
            pos = write_log_bytes(&mut buf, pos, b" -> ");
            if ptr.is_null() {
                pos = write_log_bytes(&mut buf, pos, b"NULL");
            } else {
                pos = write_log_bytes(&mut buf, pos, b"0x");
                pos = write_log_hex(&mut buf, pos, ptr as u32);
            }
            crate::debug_log(&buf[..pos]);
        }
    }
}

fn write_log_bytes(buf: &mut [u8], pos: usize, s: &[u8]) -> usize {
    let mut p = pos;
    for &b in s {
        if p >= buf.len() {
            break;
        }
        buf[p] = b;
        p += 1;
    }
    p
}

fn write_log_cstr(buf: &mut [u8], pos: usize, s: &[u8]) -> usize {
    let mut p = pos;
    for &b in s {
        if b == 0 || p >= buf.len() {
            break;
        }
        buf[p] = b;
        p += 1;
    }
    p
}

fn write_log_hex(buf: &mut [u8], pos: usize, val: u32) -> usize {
    let mut p = pos;
    let hex = b"0123456789ABCDEF";
    let mut i = 0;
    while i < 8 {
        if p >= buf.len() {
            break;
        }
        let nibble = (val >> (28 - i * 4)) & 0xF;
        buf[p] = hex[nibble as usize];
        p += 1;
        i += 1;
    }
    p
}
