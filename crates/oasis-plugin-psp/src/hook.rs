//! Display framebuffer hook via CFW syscall patching.
//!
//! Intercepts `sceDisplaySetFrameBuf` to draw the overlay on top of the
//! game's framebuffer after each frame. The hook calls the original function
//! first (so the game renders normally), then draws overlay elements.
//!
//! # Kernel stub workaround
//!
//! The PSP firmware patches kernel import stubs with `j target` (direct
//! jump) but does NOT write a `nop` to the delay slot. The delay slot
//! retains the original `Stub` struct data (a pointer), which decodes
//! to a garbage MIPS instruction and crashes when executed. We work
//! around this by extracting the jump target from the `j` instruction
//! and calling the function directly via a raw pointer, bypassing the
//! broken stub entirely.

use crate::overlay;

use core::sync::atomic::{AtomicBool, Ordering};

/// Whether the hook is currently installed.
static HOOK_INSTALLED: AtomicBool = AtomicBool::new(false);

/// Original `sceDisplaySetFrameBuf` function pointer.
static mut ORIGINAL_SET_FRAME_BUF: Option<
    unsafe extern "C" fn(*const u8, usize, u32, u32) -> u32,
> = None;

/// NID for sceDisplaySetFrameBuf.
const NID_SCE_DISPLAY_SET_FRAME_BUF: u32 = 0x289D82FE;

// Reference the raw stub symbols generated by psp_extern! for
// SystemCtrlForKernel functions. They are #[unsafe(no_mangle)] so we
// can access them from here. The firmware replaces the first 4 bytes
// with a `j target` instruction for kernel imports.
unsafe extern "C" {
    #[link_name = "__sctrlHENFindFunction_stub"]
    static FIND_FUNC_STUB: [u32; 2];

    #[link_name = "__sctrlHENPatchSyscall_stub"]
    static PATCH_SYSCALL_STUB: [u32; 2];
}

/// Extract the absolute target address from a MIPS `j` instruction.
///
/// The `j` instruction encodes a 26-bit word index. The full 32-bit
/// address is formed by combining the upper 4 bits of the PC with the
/// 28-bit target (index << 2).
///
/// Returns `None` if the instruction is not a `j` (opcode != 2).
fn extract_j_target(instruction: u32, pc: u32) -> Option<u32> {
    if (instruction >> 26) != 2 {
        return None;
    }
    let offset = (instruction & 0x03FF_FFFF) << 2;
    let region = pc & 0xF000_0000;
    Some(region | offset)
}

/// Check if a stub word looks like a resolved import.
///
/// User-mode: `jr $ra` (0x03E00008)
/// Kernel-mode: `j target` (opcode bits 31-26 == 2)
fn is_stub_resolved(first_word: u32) -> bool {
    first_word == 0x03E00008 || (first_word >> 26) == 2
}

/// Our hook function that replaces `sceDisplaySetFrameBuf`.
///
/// Called in the game's display thread context every vsync. Must be fast:
/// - Call original to let the game's frame through
/// - Poll controller for trigger button
/// - If overlay active, blit the pre-rendered overlay buffer
///
/// # Safety
/// Called by the PSP OS as a syscall replacement. Arguments match
/// `sceDisplaySetFrameBuf` signature.
unsafe extern "C" fn hooked_set_frame_buf(
    top_addr: *const u8,
    buffer_width: usize,
    pixel_format: u32,
    sync: u32,
) -> u32 {
    // Call original first so the game's frame is displayed
    // SAFETY: ORIGINAL_SET_FRAME_BUF is set before the hook is active.
    let result = unsafe {
        if let Some(original) = ORIGINAL_SET_FRAME_BUF {
            original(top_addr, buffer_width, pixel_format, sync)
        } else {
            0
        }
    };

    // Only draw overlay on 32-bit ABGR framebuffers (pixel_format == 3)
    // and valid framebuffer pointers
    if !top_addr.is_null() && pixel_format == 3 {
        let fb = top_addr as *mut u32;
        let stride = buffer_width as u32;

        // Debug beacon: 2x2 green dot at (1,1) confirms the hook is running.
        // Remove once overlay is confirmed working.
        // SAFETY: Writing within screen bounds to valid framebuffer.
        unsafe {
            *fb.add((1 * stride + 1) as usize) = 0xFF00FF00;
            *fb.add((1 * stride + 2) as usize) = 0xFF00FF00;
            *fb.add((2 * stride + 1) as usize) = 0xFF00FF00;
            *fb.add((2 * stride + 2) as usize) = 0xFF00FF00;
        }

        // SAFETY: fb is a valid framebuffer pointer provided by the OS.
        // stride is the buffer width in pixels. We only write within
        // screen bounds (480x272).
        unsafe {
            overlay::on_frame(fb, stride);
        }
    }

    result
}

/// Module/library name pairs to try for finding sceDisplaySetFrameBuf.
///
/// Different CFW versions and firmware versions expose the display driver
/// under different module names. We try them in order until one works.
const DISPLAY_MODULE_NAMES: &[(&[u8], &[u8])] = &[
    (b"sceDisplay_Service\0", b"sceDisplay\0"),
    (b"sceDisplay\0", b"sceDisplay\0"),
    (b"sceDisplay_Service\0", b"sceDisplay_driver\0"),
    (b"sceDisplay\0", b"sceDisplay_driver\0"),
];

/// Resolve a kernel import stub to a direct function pointer.
///
/// Reads the `j target` instruction from the stub, extracts the
/// absolute target address, and returns it. This bypasses the broken
/// delay slot in kernel stubs (firmware doesn't write nop there).
///
/// Returns `None` if the stub wasn't resolved by the firmware.
unsafe fn resolve_kernel_stub(stub: &[u32; 2]) -> Option<u32> {
    let first_word = unsafe {
        core::ptr::read_volatile(&raw const *stub as *const u32)
    };
    if !is_stub_resolved(first_word) {
        return None;
    }
    // For user-mode stubs (jr $ra; syscall), calling through the
    // wrapper is safe. But we only get here for kernel stubs.
    let stub_addr = &raw const *stub as u32;
    extract_j_target(first_word, stub_addr)
}

/// Install the `sceDisplaySetFrameBuf` hook.
///
/// Returns `true` on success. Must be called from kernel mode during plugin
/// initialization.
pub fn install_display_hook() -> bool {
    if HOOK_INSTALLED.load(Ordering::Relaxed) {
        return true;
    }

    // Log raw stub bytes for diagnostics.
    {
        // SAFETY: Reading stub bytes for diagnostics.
        let (w0, w1) = unsafe {
            let p = &raw const FIND_FUNC_STUB as *const u32;
            (
                core::ptr::read_volatile(p),
                core::ptr::read_volatile(p.add(1)),
            )
        };
        let mut buf = [0u8; 64];
        let mut pos = write_log_bytes(&mut buf, 0, b"[OASIS] stub: ");
        pos = write_log_hex(&mut buf, pos, w0);
        pos = write_log_bytes(&mut buf, pos, b" ");
        pos = write_log_hex(&mut buf, pos, w1);
        crate::debug_log(&buf[..pos]);
    }

    // Resolve CFW function pointers by extracting j-targets from the
    // patched stubs. This bypasses the broken delay slot.
    // SAFETY: Reading stub data that was written by firmware at load time.
    let find_func_addr = unsafe { resolve_kernel_stub(&FIND_FUNC_STUB) };
    let patch_syscall_addr = unsafe { resolve_kernel_stub(&PATCH_SYSCALL_STUB) };

    let (find_addr, patch_addr) = match (find_func_addr, patch_syscall_addr) {
        (Some(f), Some(p)) => {
            let mut buf = [0u8; 64];
            let mut pos = write_log_bytes(&mut buf, 0, b"[OASIS] FindFunc=0x");
            pos = write_log_hex(&mut buf, pos, f);
            pos = write_log_bytes(&mut buf, pos, b" Patch=0x");
            pos = write_log_hex(&mut buf, pos, p);
            crate::debug_log(&buf[..pos]);
            (f, p)
        }
        _ => {
            crate::debug_log(b"[OASIS] hook: sctrl stubs NOT resolved!");
            return false;
        }
    };

    // Cast to function pointer types matching the CFW API signatures.
    // SAFETY: Addresses extracted from firmware-patched import stubs.
    let sctrl_find_function: unsafe extern "C" fn(
        *const u8, *const u8, u32,
    ) -> *mut u8 = unsafe { core::mem::transmute(find_addr) };

    let sctrl_patch_syscall: unsafe extern "C" fn(
        *mut u8, *mut u8,
    ) -> i32 = unsafe { core::mem::transmute(patch_addr) };

    // Wait for CFW and game to fully initialize before calling CFW APIs.
    crate::debug_log(b"[OASIS] hook: waiting for system init...");
    unsafe {
        psp::sys::sceKernelDelayThread(2_000_000); // 2 seconds
    }
    crate::debug_log(b"[OASIS] hook: calling FindFunc...");

    unsafe {
        psp::sys::sceKernelDcacheWritebackAll();

        // Try each module/library name combination until one returns a
        // valid function pointer for sceDisplaySetFrameBuf.
        let mut display_ptr: *mut u8 = core::ptr::null_mut();
        for &(module, library) in DISPLAY_MODULE_NAMES {
            let ptr = sctrl_find_function(
                module.as_ptr(),
                library.as_ptr(),
                NID_SCE_DISPLAY_SET_FRAME_BUF,
            );
            if !ptr.is_null() {
                display_ptr = ptr;

                let mut buf = [0u8; 80];
                let mut pos = write_log_bytes(&mut buf, 0, b"[OASIS] found at mod=");
                pos = write_log_cstr(&mut buf, pos, module);
                pos = write_log_bytes(&mut buf, pos, b" -> 0x");
                pos = write_log_hex(&mut buf, pos, ptr as u32);
                crate::debug_log(&buf[..pos]);
                break;
            }
        }

        if display_ptr.is_null() {
            crate::debug_log(b"[OASIS] hook: FindFunc returned NULL for all");
            return false;
        }

        crate::debug_log(b"[OASIS] hook: calling PatchSyscall...");
        let ret = sctrl_patch_syscall(
            display_ptr,
            hooked_set_frame_buf as *mut u8,
        );
        if ret < 0 {
            crate::debug_log(b"[OASIS] hook: PatchSyscall FAILED");
            return false;
        }

        crate::debug_log(b"[OASIS] hook: PatchSyscall OK");
        ORIGINAL_SET_FRAME_BUF = Some(core::mem::transmute(display_ptr));

        psp::sys::sceKernelIcacheInvalidateAll();
        psp::sys::sceKernelDcacheWritebackAll();

        HOOK_INSTALLED.store(true, Ordering::Release);
    }

    true
}

/// Log diagnostic info about sctrlHENFindFunction results.
///
/// Tries all known module/library name combinations and logs which ones
/// return a valid pointer vs null. Writes to the debug log file.
pub fn log_find_function_result() {
    // SAFETY: Resolving the kernel stub for direct calls.
    let find_addr = unsafe { resolve_kernel_stub(&FIND_FUNC_STUB) };
    let Some(addr) = find_addr else {
        crate::debug_log(b"[OASIS] log: skipping (stubs not resolved)");
        return;
    };

    let sctrl_find_function: unsafe extern "C" fn(
        *const u8, *const u8, u32,
    ) -> *mut u8 = unsafe { core::mem::transmute(addr) };

    // SAFETY: Calling the resolved CFW function from kernel mode.
    unsafe {
        for &(module, library) in DISPLAY_MODULE_NAMES {
            let ptr = sctrl_find_function(
                module.as_ptr(),
                library.as_ptr(),
                NID_SCE_DISPLAY_SET_FRAME_BUF,
            );

            let mut buf = [0u8; 96];
            let mut pos = 0usize;
            pos = write_log_bytes(&mut buf, pos, b"[OASIS] FindFunc mod=");
            pos = write_log_cstr(&mut buf, pos, module);
            pos = write_log_bytes(&mut buf, pos, b" lib=");
            pos = write_log_cstr(&mut buf, pos, library);
            pos = write_log_bytes(&mut buf, pos, b" -> ");
            if ptr.is_null() {
                pos = write_log_bytes(&mut buf, pos, b"NULL");
            } else {
                pos = write_log_bytes(&mut buf, pos, b"0x");
                pos = write_log_hex(&mut buf, pos, ptr as u32);
            }
            crate::debug_log(&buf[..pos]);
        }
    }
}

/// Write bytes into a log buffer. Returns new position.
fn write_log_bytes(buf: &mut [u8], pos: usize, s: &[u8]) -> usize {
    let mut p = pos;
    for &b in s {
        if p >= buf.len() {
            break;
        }
        buf[p] = b;
        p += 1;
    }
    p
}

/// Write a null-terminated C string (without the null) into a log buffer.
fn write_log_cstr(buf: &mut [u8], pos: usize, s: &[u8]) -> usize {
    let mut p = pos;
    for &b in s {
        if b == 0 || p >= buf.len() {
            break;
        }
        buf[p] = b;
        p += 1;
    }
    p
}

/// Write a u32 as hexadecimal into a log buffer.
fn write_log_hex(buf: &mut [u8], pos: usize, val: u32) -> usize {
    let mut p = pos;
    let hex = b"0123456789ABCDEF";
    let mut i = 0;
    while i < 8 {
        if p >= buf.len() {
            break;
        }
        let nibble = (val >> (28 - i * 4)) & 0xF;
        buf[p] = hex[nibble as usize];
        p += 1;
        i += 1;
    }
    p
}
