//! Display framebuffer hook via CFW syscall patching.
//!
//! Intercepts `sceDisplaySetFrameBuf` to draw the overlay on top of the
//! game's framebuffer after each frame. The hook calls the original function
//! first (so the game renders normally), then draws overlay elements.

use crate::overlay;

use core::sync::atomic::{AtomicBool, Ordering};

/// Whether the hook is currently installed.
static HOOK_INSTALLED: AtomicBool = AtomicBool::new(false);

/// Original `sceDisplaySetFrameBuf` function pointer.
static mut ORIGINAL_SET_FRAME_BUF: Option<
    unsafe extern "C" fn(*const u8, usize, u32, u32) -> u32,
> = None;

/// NID for sceDisplaySetFrameBuf.
const NID_SCE_DISPLAY_SET_FRAME_BUF: u32 = 0x289D82FE;

// Reference the raw stub symbol generated by psp_extern! for
// sctrlHENFindFunction. It is #[unsafe(no_mangle)] so we can access it
// from here. The firmware replaces this 8-byte region with `jr $ra;
// syscall N` at module load time if the import was resolved.
unsafe extern "C" {
    #[link_name = "__sctrlHENFindFunction_stub"]
    static FIND_FUNC_STUB: [u32; 2];
}

/// Check if the SystemCtrlForKernel import stubs were resolved by firmware.
///
/// A resolved stub starts with `jr $ra` (0x03E00008). An unresolved stub
/// contains the raw `Stub` struct data (two pointers to lib entry and NID).
fn is_sctrl_resolved() -> bool {
    // SAFETY: Reading the stub bytes to check if they were patched.
    // The symbol is valid as long as the psp crate is linked.
    unsafe {
        let first_word = core::ptr::read_volatile(&raw const FIND_FUNC_STUB as *const u32);
        first_word == 0x03E00008 // jr $ra
    }
}

/// Our hook function that replaces `sceDisplaySetFrameBuf`.
///
/// Called in the game's display thread context every vsync. Must be fast:
/// - Call original to let the game's frame through
/// - Poll controller for trigger button
/// - If overlay active, blit the pre-rendered overlay buffer
///
/// # Safety
/// Called by the PSP OS as a syscall replacement. Arguments match
/// `sceDisplaySetFrameBuf` signature.
unsafe extern "C" fn hooked_set_frame_buf(
    top_addr: *const u8,
    buffer_width: usize,
    pixel_format: u32,
    sync: u32,
) -> u32 {
    // Call original first so the game's frame is displayed
    // SAFETY: ORIGINAL_SET_FRAME_BUF is set before the hook is active.
    let result = unsafe {
        if let Some(original) = ORIGINAL_SET_FRAME_BUF {
            original(top_addr, buffer_width, pixel_format, sync)
        } else {
            0
        }
    };

    // Only draw overlay on 32-bit ABGR framebuffers (pixel_format == 3)
    // and valid framebuffer pointers
    if !top_addr.is_null() && pixel_format == 3 {
        let fb = top_addr as *mut u32;
        let stride = buffer_width as u32;

        // Debug beacon: 2x2 green dot at (1,1) confirms the hook is running.
        // Remove once overlay is confirmed working.
        // SAFETY: Writing within screen bounds to valid framebuffer.
        unsafe {
            *fb.add((1 * stride + 1) as usize) = 0xFF00FF00;
            *fb.add((1 * stride + 2) as usize) = 0xFF00FF00;
            *fb.add((2 * stride + 1) as usize) = 0xFF00FF00;
            *fb.add((2 * stride + 2) as usize) = 0xFF00FF00;
        }

        // SAFETY: fb is a valid framebuffer pointer provided by the OS.
        // stride is the buffer width in pixels. We only write within
        // screen bounds (480x272).
        unsafe {
            overlay::on_frame(fb, stride);
        }
    }

    result
}

/// Module/library name pairs to try for finding sceDisplaySetFrameBuf.
///
/// Different CFW versions and firmware versions expose the display driver
/// under different module names. We try them in order until one works.
const DISPLAY_MODULE_NAMES: &[(&[u8], &[u8])] = &[
    (b"sceDisplay_Service\0", b"sceDisplay\0"),
    (b"sceDisplay\0", b"sceDisplay\0"),
    (b"sceDisplay_Service\0", b"sceDisplay_driver\0"),
    (b"sceDisplay\0", b"sceDisplay_driver\0"),
];

/// Install the `sceDisplaySetFrameBuf` hook.
///
/// Returns `true` on success. Must be called from kernel mode during plugin
/// initialization.
pub fn install_display_hook() -> bool {
    if HOOK_INSTALLED.load(Ordering::Relaxed) {
        return true;
    }

    // Check if SystemCtrlForKernel import stubs were resolved by firmware.
    // The stub should contain `jr $ra; syscall N` if resolved.
    {
        // SAFETY: Reading stub bytes for diagnostics.
        let (w0, w1) = unsafe {
            let p = &raw const FIND_FUNC_STUB as *const u32;
            (
                core::ptr::read_volatile(p),
                core::ptr::read_volatile(p.add(1)),
            )
        };
        let mut buf = [0u8; 64];
        let mut pos = write_log_bytes(&mut buf, 0, b"[OASIS] stub: ");
        pos = write_log_hex(&mut buf, pos, w0);
        pos = write_log_bytes(&mut buf, pos, b" ");
        pos = write_log_hex(&mut buf, pos, w1);
        crate::debug_log(&buf[..pos]);
    }

    if !is_sctrl_resolved() {
        crate::debug_log(b"[OASIS] hook: sctrl stubs NOT resolved by FW!");
        crate::debug_log(b"[OASIS] hook: SystemCtrlForKernel unavailable");
        return false;
    }
    crate::debug_log(b"[OASIS] hook: sctrl stubs resolved OK");

    // Wait for CFW and game to fully initialize before calling CFW APIs.
    // sctrlHENFindFunction may crash if called too early (before
    // SystemControl's internal module list is populated).
    crate::debug_log(b"[OASIS] hook: waiting for system init...");
    unsafe {
        psp::sys::sceKernelDelayThread(2_000_000); // 2 seconds
    }
    crate::debug_log(b"[OASIS] hook: calling FindFunc...");

    unsafe {
        psp::sys::sceKernelDcacheWritebackAll();

        // Try each module/library name combination until one returns a
        // valid function pointer for sceDisplaySetFrameBuf.
        let mut display_ptr: *mut u8 = core::ptr::null_mut();
        for &(module, library) in DISPLAY_MODULE_NAMES {
            let ptr = psp::sys::sctrlHENFindFunction(
                module.as_ptr(),
                library.as_ptr(),
                NID_SCE_DISPLAY_SET_FRAME_BUF,
            );
            if !ptr.is_null() {
                display_ptr = ptr;

                let mut buf = [0u8; 80];
                let mut pos = write_log_bytes(&mut buf, 0, b"[OASIS] found at mod=");
                pos = write_log_cstr(&mut buf, pos, module);
                pos = write_log_bytes(&mut buf, pos, b" -> 0x");
                pos = write_log_hex(&mut buf, pos, ptr as u32);
                crate::debug_log(&buf[..pos]);
                break;
            }
        }

        if display_ptr.is_null() {
            crate::debug_log(b"[OASIS] hook: FindFunc returned NULL for all");
            return false;
        }

        crate::debug_log(b"[OASIS] hook: calling PatchSyscall...");
        let ret = psp::sys::sctrlHENPatchSyscall(
            display_ptr,
            hooked_set_frame_buf as *mut u8,
        );
        if ret < 0 {
            crate::debug_log(b"[OASIS] hook: PatchSyscall FAILED");
            return false;
        }

        crate::debug_log(b"[OASIS] hook: PatchSyscall OK");
        ORIGINAL_SET_FRAME_BUF = Some(core::mem::transmute(display_ptr));

        psp::sys::sceKernelIcacheInvalidateAll();
        psp::sys::sceKernelDcacheWritebackAll();

        HOOK_INSTALLED.store(true, Ordering::Release);
    }

    true
}

/// Log diagnostic info about sctrlHENFindFunction results.
///
/// Tries all known module/library name combinations and logs which ones
/// return a valid pointer vs null. Writes to the debug log file.
pub fn log_find_function_result() {
    if !is_sctrl_resolved() {
        crate::debug_log(b"[OASIS] log: skipping (stubs not resolved)");
        return;
    }

    // SAFETY: sctrlHENFindFunction is safe to call from kernel mode.
    // It just looks up function pointers without side effects.
    unsafe {
        for &(module, library) in DISPLAY_MODULE_NAMES {
            let ptr = psp::sys::sctrlHENFindFunction(
                module.as_ptr(),
                library.as_ptr(),
                NID_SCE_DISPLAY_SET_FRAME_BUF,
            );

            // Build log message: "[OASIS] FindFunc mod=X lib=Y -> 0xADDR"
            let mut buf = [0u8; 96];
            let mut pos = 0usize;
            pos = write_log_bytes(&mut buf, pos, b"[OASIS] FindFunc mod=");
            // Copy module name (without null terminator)
            pos = write_log_cstr(&mut buf, pos, module);
            pos = write_log_bytes(&mut buf, pos, b" lib=");
            pos = write_log_cstr(&mut buf, pos, library);
            pos = write_log_bytes(&mut buf, pos, b" -> ");
            if ptr.is_null() {
                pos = write_log_bytes(&mut buf, pos, b"NULL");
            } else {
                pos = write_log_bytes(&mut buf, pos, b"0x");
                pos = write_log_hex(&mut buf, pos, ptr as u32);
            }
            crate::debug_log(&buf[..pos]);
        }
    }
}

/// Write bytes into a log buffer. Returns new position.
fn write_log_bytes(buf: &mut [u8], pos: usize, s: &[u8]) -> usize {
    let mut p = pos;
    for &b in s {
        if p >= buf.len() {
            break;
        }
        buf[p] = b;
        p += 1;
    }
    p
}

/// Write a null-terminated C string (without the null) into a log buffer.
fn write_log_cstr(buf: &mut [u8], pos: usize, s: &[u8]) -> usize {
    let mut p = pos;
    for &b in s {
        if b == 0 || p >= buf.len() {
            break;
        }
        buf[p] = b;
        p += 1;
    }
    p
}

/// Write a u32 as hexadecimal into a log buffer.
fn write_log_hex(buf: &mut [u8], pos: usize, val: u32) -> usize {
    let mut p = pos;
    let hex = b"0123456789ABCDEF";
    // Write 8 hex digits
    let mut i = 0;
    while i < 8 {
        if p >= buf.len() {
            break;
        }
        let nibble = (val >> (28 - i * 4)) & 0xF;
        buf[p] = hex[nibble as usize];
        p += 1;
        i += 1;
    }
    p
}
