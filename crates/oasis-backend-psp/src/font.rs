//! Font rendering: system TrueType fonts (via `psp::font`) with 8x8 bitmap
//! fallback.
//!
//! The bitmap font covers printable ASCII (0x20 - 0x7E, 95 glyphs). Each
//! glyph is 8 rows of 8 bits, MSB = leftmost pixel. Based on the classic
//! IBM CGA/BIOS 8x8 font (public domain).
//!
//! `SystemFont` wraps the PSP's built-in TrueType font library, providing
//! anti-aliased rendering via a VRAM glyph atlas. Falls back to bitmap if
//! system fonts are unavailable (e.g. PPSSPP emulator).

use std::pin::Pin;

use psp::font::{Font, FontLib, FontRenderer};
use psp::sys::{SceFontFamilyCode, SceFontLanguageCode, SceFontStyleCode};

/// System font wrapper (FontLib + Font + FontRenderer with VRAM atlas).
///
/// Manages the self-referential FontRenderer<'a> -> &'a Font relationship
/// via a `Pin<Box<Font>>` that guarantees the heap address is stable.
///
/// Drop order matters: `renderer` is declared first and therefore dropped
/// first, before `_font` and `_fontlib` (Rust drops fields in declaration
/// order).
pub struct SystemFont {
    // Drop order: renderer first, then font, then fontlib.
    renderer: Option<FontRenderer<'static>>,
    _font: Pin<Box<Font>>,
    _fontlib: FontLib,
}

impl SystemFont {
    /// Try to initialize system fonts. Returns `None` if unavailable.
    pub fn try_init(atlas_vram: *mut u8) -> Option<Self> {
        let fontlib = FontLib::new(1).ok()?;
        let font = fontlib
            .find_optimum(
                SceFontFamilyCode::SansSerif,
                SceFontStyleCode::Regular,
                SceFontLanguageCode::Latin,
            )
            .ok()?;
        let font = Box::pin(font);

        // SAFETY: The Font is behind Pin<Box<_>>, guaranteeing its heap
        // address is stable for the lifetime of `_font`. The renderer is
        // dropped before _font (struct field declaration order), so the
        // reference remains valid for the entire lifetime of `renderer`.
        let font_ref: &'static Font =
            unsafe { &*(font.as_ref().get_ref() as *const Font) };
        let renderer = FontRenderer::new(font_ref, atlas_vram, 12.0);

        Some(Self {
            renderer: Some(renderer),
            _font: font,
            _fontlib: fontlib,
        })
    }

    /// Queue text for drawing. Call `flush()` after all text is queued.
    pub fn draw_text(&mut self, x: f32, y: f32, color_abgr: u32, text: &str) {
        if let Some(r) = &mut self.renderer {
            r.draw_text(x, y, color_abgr, text);
        }
    }

    /// Measure the width of a text string in pixels.
    pub fn measure_text(&self, text: &str) -> f32 {
        self.renderer
            .as_ref()
            .map_or(0.0, |r| r.measure_text(text))
    }

    /// Get the line height in pixels.
    pub fn line_height(&self) -> f32 {
        self.renderer
            .as_ref()
            .map_or(12.0, |r| r.line_height())
    }

    /// Submit all queued glyph sprites to the GU.
    ///
    /// # Safety
    /// Must be called within an active GU display list.
    pub unsafe fn flush(&mut self) {
        if let Some(r) = &mut self.renderer {
            // SAFETY: Caller guarantees we're in an active GU display list.
            unsafe { r.flush() };
        }
    }
}

/// Width of each glyph in pixels.
pub const GLYPH_WIDTH: u32 = 8;

/// Height of each glyph in pixels.
#[allow(dead_code)]
pub const GLYPH_HEIGHT: u32 = 8;

/// First printable ASCII code in the table.
const FIRST_CHAR: u8 = 0x20;

/// Last printable ASCII code in the table.
const LAST_CHAR: u8 = 0x7E;

/// 95 glyphs, 8 bytes each (ASCII 32-126).
#[rustfmt::skip]
static FONT_DATA: [[u8; 8]; 95] = [
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], //   (32)
    [0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00], // ! (33)
    [0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00], // " (34)
    [0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00], // # (35)
    [0x18, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x18, 0x00], // $ (36)
    [0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00], // % (37)
    [0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00], // & (38)
    [0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00], // ' (39)
    [0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00], // ( (40)
    [0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00], // ) (41)
    [0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00], // * (42)
    [0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00], // + (43)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30], // , (44)
    [0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00], // - (45)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00], // . (46)
    [0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00], // / (47)
    [0x3C, 0x66, 0x6E, 0x7E, 0x76, 0x66, 0x3C, 0x00], // 0 (48)
    [0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00], // 1 (49)
    [0x3C, 0x66, 0x06, 0x0C, 0x18, 0x30, 0x7E, 0x00], // 2 (50)
    [0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00], // 3 (51)
    [0x0C, 0x1C, 0x3C, 0x6C, 0x7E, 0x0C, 0x0C, 0x00], // 4 (52)
    [0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00], // 5 (53)
    [0x1C, 0x30, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00], // 6 (54)
    [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00], // 7 (55)
    [0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00], // 8 (56)
    [0x3C, 0x66, 0x66, 0x3E, 0x06, 0x0C, 0x38, 0x00], // 9 (57)
    [0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00], // : (58)
    [0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30], // ; (59)
    [0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00], // < (60)
    [0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00], // = (61)
    [0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x00], // > (62)
    [0x3C, 0x66, 0x06, 0x0C, 0x18, 0x00, 0x18, 0x00], // ? (63)
    [0x3C, 0x66, 0x6E, 0x6A, 0x6E, 0x60, 0x3C, 0x00], // @ (64)
    [0x18, 0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x00], // A (65)
    [0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00], // B (66)
    [0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00], // C (67)
    [0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00], // D (68)
    [0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x7E, 0x00], // E (69)
    [0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x00], // F (70)
    [0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3E, 0x00], // G (71)
    [0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00], // H (72)
    [0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00], // I (73)
    [0x06, 0x06, 0x06, 0x06, 0x06, 0x66, 0x3C, 0x00], // J (74)
    [0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00], // K (75)
    [0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00], // L (76)
    [0xC6, 0xEE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0x00], // M (77)
    [0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00], // N (78)
    [0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00], // O (79)
    [0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00], // P (80)
    [0x3C, 0x66, 0x66, 0x66, 0x6A, 0x6C, 0x36, 0x00], // Q (81)
    [0x7C, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0x00], // R (82)
    [0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00], // S (83)
    [0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00], // T (84)
    [0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00], // U (85)
    [0x66, 0x66, 0x66, 0x66, 0x3C, 0x3C, 0x18, 0x00], // V (86)
    [0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00], // W (87)
    [0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00], // X (88)
    [0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00], // Y (89)
    [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00], // Z (90)
    [0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00], // [ (91)
    [0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00], // \ (92)
    [0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00], // ] (93)
    [0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00], // ^ (94)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE], // _ (95)
    [0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00], // ` (96)
    [0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E, 0x00], // a (97)
    [0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x00], // b (98)
    [0x00, 0x00, 0x3C, 0x66, 0x60, 0x66, 0x3C, 0x00], // c (99)
    [0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00], // d (100)
    [0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00], // e (101)
    [0x0E, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x18, 0x00], // f (102)
    [0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x3C], // g (103)
    [0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00], // h (104)
    [0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00], // i (105)
    [0x06, 0x00, 0x06, 0x06, 0x06, 0x06, 0x66, 0x3C], // j (106)
    [0x60, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0x00], // k (107)
    [0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00], // l (108)
    [0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xC6, 0xC6, 0x00], // m (109)
    [0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00], // n (110)
    [0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00], // o (111)
    [0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60], // p (112)
    [0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x06], // q (113)
    [0x00, 0x00, 0x7C, 0x66, 0x60, 0x60, 0x60, 0x00], // r (114)
    [0x00, 0x00, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x00], // s (115)
    [0x18, 0x18, 0x7E, 0x18, 0x18, 0x18, 0x0E, 0x00], // t (116)
    [0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00], // u (117)
    [0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00], // v (118)
    [0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xFE, 0x6C, 0x00], // w (119)
    [0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x00], // x (120)
    [0x00, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x3C], // y (121)
    [0x00, 0x00, 0x7E, 0x0C, 0x18, 0x30, 0x7E, 0x00], // z (122)
    [0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00], // { (123)
    [0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00], // | (124)
    [0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00], // } (125)
    [0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // ~ (126)
];

/// Look up glyph data for a character. Returns 8 bytes (one per row).
/// Non-printable or out-of-range characters get a filled-block fallback.
pub fn glyph(ch: char) -> &'static [u8; 8] {
    let code = ch as u32;
    if code >= FIRST_CHAR as u32 && code <= LAST_CHAR as u32 {
        &FONT_DATA[(code - FIRST_CHAR as u32) as usize]
    } else {
        // Fallback: filled block.
        static FALLBACK: [u8; 8] = [0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0x00];
        &FALLBACK
    }
}
